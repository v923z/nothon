{
"title" : "Comments on using the nothon notebook<br>",
"type": "notebook",
"directory" : "/home/v923z/sandbox/nothon/notebooks/",
"date" : "Mon Aug 12 2013 22:41:36 GMT+0200 (CEST)",
"nothon version" : 1.2,
"notebook" : [
    {
        "content": {
            "text_body": {
                "content": "On the following pages, we would like to outline the rationale behind the creation of <i>nothon</i>, and give the user a couple of tips on the efficient use of the notebook. At the end, we will also show how the behaviour of nothon can be customised, and how new features can easily be added.<br><br>",
                "id": "div_text_body_10",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Introduction",
                "id": "div_text_header_10",
                "props": "searchable;intoc;"
            }
        },
        "id": 10,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "Or, put differently, what is wrong with wikis in general? There are several problems with the wiki approach. <br><ol><li>Extra content (images, sound etc.) has to be uploaded to a server, creating a storage/management overhead.</li><li>Formatting cannot be done, and formulae cannot be edited in-place: one has to invoke the editor mode for each section.</li><li>There is no way of creating content in the wiki page itself (we mean data external to the wiki page itself. E.g., a figure/plot has to be created in an external application, and then uploaded to the server).<br></li></ol><p>The first of the problems was alleviated in the excellent zim-wiki project, which, exactly because it doesn't require a server, works with the underlying file system. In some respect, the third point was also addressed in zim, namely, there is a way of creating plots and formulae on the fly. However, formulae require a LaTeX system, which has its own problems, while the script that generates the plot is hidden. This can be an advantage or disadvantage, depending on the particular situation (or the preferences of the user). <br></p><hr>When we set out to develop nothon, we wanted to rectify the above-mentioned problems. However, since the desire was to create a system that can be used for documenting various projects (both experimental, and theoretical/numerical), we also wanted to include tools that would make project management easy. Thus, we envisaged the following features.<br><ol><li>Easy customisation: in terms of both adding extensions, and the look and feel of the wiki. We also thought that customisation is a rather important subject in the sense that we cannot possibly think of all uses, and we wanted to implement a wiki in a way that can be modified via a plug-in infrastructure. <br></li><li>Integration of a (or multiple) scientific plotting utility.&nbsp;</li><li>Some interaction with the file system. This would include accessing the content of data files, and retrieving and highlighting the content of software code. On can also think about saving particular cells of a document. E.g., the script producing a figure could be saved as a stand-alone file. <br></li><li>Portability.<br></li></ol><p>As for the first point, the browser seemed to be a natural choice: given the HTML content, customisation can be done with the help of cascaded stylesheets. In this way, not only could we completely decouple the content from the presentation, but the decoupling would work at the level of the code, too. In other words, the server-client separation naturally lends itself to a double-headed implementation: the server can deal with access to the file system, plotting and the like, while the browser's responsibility is to handle the user interaction.&nbsp; Resorting to the browser has the additional benefit that the content of a notebook can easily converted to a format that is widely used, and portability is not a problem either. <br></p>",
                "id": "div_text_body_11",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Why another wiki?",
                "id": "div_text_header_11",
                "props": "searchable;intoc;"
            }
        },
        "id": 11,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "The most recent version of the source code resides at https://github.com/v923z/nothon<br>The code has minimal dependencies, most of which are probably installed on any linux distribution. In order to have plotting, either matplotlib, or gnuplot has to be installed. Beyond this, the only dependency is web.py, in which the server is implemented. <br><br>After starting nothon.py, the notebook can be accessed from the browser at address <br><br>http://127.0.0.1:8080/?name=somenotebook.note<br><br>If the notebook exists (this should be a JSON file), then its content will be rendered in the browser. If it doesn't exist, then a new notebook with that name will be created. When saving this notebook, its content will be written to disc under the name somenotebook.note. <br><br>Once in the browser, a new divide (or cell) can be added by clicking on the appropriate label under the + sign on the right hand side. The active div's parent (indicated by a thick right-hand-side border, though, as stated above, visual features can be manipulated in the appropriate CSS file) can be removed by clicking on remove. This operation moves the divide to the trash, which is part of the document, but is hidden. (The trash can be made visible by clicking on the trashbin icon on the lower right corner.) By clicking on recover, either the active block of the trashbin, or if that does not exist, then the last block in the trash is restored to the visible part of the document, and is inserted as the last divide. Blocks of the document can be moved up or down by clicking on the up or down arrow on the right hand side. <br>",
                "id": "div_text_body_7",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Beginning with nothon",
                "id": "div_text_header_7",
                "props": "searchable;intoc;"
            }
        },
        "id": 7,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "Headers in text, code, and head blocks are evaluated by pressing `Enter`. This moves the cursor to the body of a text header, or sends a request to the server to execute and return the output of the corresponding handler function. <br><br>Units can be \"executed\" by pressing `Cntr+Enter`. This will render mathematical formulae in a text block, or execute a plot. If `Shift+Enter` is pressed, a new block of the same type is also inserted into the notebook.",
                "id": "div_text_body_8",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Usage in general terms",
                "id": "div_text_header_8",
                "props": "searchable;intoc;"
            }
        },
        "id": 8,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "As a general rule, all labels, buttons etc. of nothon can be hidden: they are there to help the user, but not to distract them. Therefore, when not needed, the user can hide everything except the notebook itself. <br><br>At the top of the notebook, a toolbar can be found. This contains links to various actions. <br><br>ToC and Timeline refer to the table of contents (a list of all content-manageable headers of all notebooks), and an ordered list of all notebooks in the Calendar section. When pressing either button, the user is taken to a new page.<br><br>The Notebook button gives access to saving, and various converting functions (saving in HTML and PDF format), and collapsing/expanding all cells of the notebook.<br><br>The Cell button insert a new cell of the chosen type.<br><br>The Menu button toggles the context-dependent menu on the right hand side. This sidebar contains commands relevant to the currently active cell. On the top of the menu, the type of the currently active cell is also shown. <br><br>The Hide button hides the toolbar. It can be made to reappear by moving the mouse to the very top of the page. <br>",
                "id": "div_text_body_12",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Using the nothon menus",
                "id": "div_text_header_12",
                "props": "searchable;intoc;"
            }
        },
        "id": 12,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "The visual appearance of a notebook can be influenced by changing the appropriate parameters in the cascaded style sheet. These modifications do not change the behaviour of the server or the client. <br><br>Several aspects of the behaviour of the server can be customised in a resource file (in future versions, this will be extended to the client, too.) By default, only png files are created, when the user plots in the notebook. By changing the value of the variable self.plot_pdf_output to True, the plotting backend will generate pdf output, too. This output can later be included in latex files. <br><br>The ordering of the directory tree (on the left hand side of the browser window, although, again, the position of this can be modified in the CSS file) can be customised. By default, the server sends the tree ordered linux style, i.e., in each folder, the files are listed first, and then the folders. By setting the variable self.dirlisting_style to \"windows\", folders will be shown first, and then files.<br><br>When working with code (see below), it might be useful to include only a function or a segment of a code file. This can be done by defining a start and end tag in the source code, and supplying that to the code handler. In order for the code highlighter to know what amounts to the beginning/ending of a code segment, the tag is prepended and appended with a beginning/closing string. This can be defined in the variable self.code_delimiter. E.g., if self.code_delimiter = ('*-', '-*'), then the code should be enclosed between the tags <br><br>&nbsp;&nbsp;&nbsp; *- some_tag<br>&nbsp;&nbsp;&nbsp; .... code ....<br>&nbsp;&nbsp; some_tag -*<br><br>The user can define arbitrary tag combination. <br>",
                "id": "div_text_body_9",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Customisation",
                "id": "div_text_header_9",
                "props": "searchable;intoc;"
            }
        },
        "id": 9,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "Arbitrary code files on the hard disc can be displayed conveniently. All one has to do is give the file name in the header (the only editable div) of a code cell.<br>",
                "id": "div_text_body_4",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Code segments 1.",
                "id": "div_text_header_4",
                "props": "searchable;intoc;"
            }
        },
        "id": 4,
        "type": "text"
    },
    {
        "content": {
            "code_body": {
                "content": "import os\n\ndef retreive_header(args):\n\thead = args.split('<br>')\n\tsp = head[0].split(' ')\n\tif not os.path.exists(sp[0]): \n\t\treturn \"File doesn't exist\"\n\tif len(sp) == 1: n = 10\n\t# TODO: elif sp[1] == '#':\t\n\telse: n = int(sp[1])\n\tfin = open(sp[0], 'r')\t\n\t# *- function_something \n\tif n > 0:\n\t\tlines = []\n\t\tit = 0\n\t\tfor line in fin:\n\t\t\tlines.append(line.rstrip('\\n\\r'))\n\t\t\tit += 1\n\t\t\tif it >= n: break\n\t# function_something -*\n\tif n < 0:\n\t\tlines = fin.readlines()\n\t\tlines = lines[-10:]\n\tfin.close()\t\n\treturn '<br>'.join([x.rstrip('\\n\\r') for x in lines])\n",
                "id": "div_code_body_1",
                "props": "collapsed;"
            },
            "code_date": {
                "content": "Created: Fri Mar 22 21:05:47 2013, modified: Fri Mar 22 21:05:47 2013",
                "id": "div_code_date_1",
                "props": ""
            },
            "code_header": {
                "content": "helper.py",
                "id": "div_code_header_1",
                "props": "intoc;"
            }
        },
        "id": 1,
        "type": "code"
    },
    {
        "content": {
            "text_body": {
                "content": "Code lines can be numbered by adding -lineno on the command line. In addition, if a start and end tag are defined in the source file, the code highlighter can be made to display only the segment between the two strings. If -include is specified on the command line, the tags are also included in the highlit code. This can be useful when one wants to emphasise that we are dealing with a code segment only.<br>",
                "id": "div_text_body_5",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Working with code 2.",
                "id": "div_text_header_5",
                "props": "searchable;intoc;"
            }
        },
        "id": 5,
        "type": "text"
    },
    {
        "content": {
            "code_body": {
                "content": "\t# *- function_something \n\tif n > 0:\n\t\tlines = []\n\t\tit = 0\n\t\tfor line in fin:\n\t\t\tlines.append(line.rstrip('\\n\\r'))\n\t\t\tit += 1\n\t\t\tif it >= n: break\n\t# function_something -*\n",
                "id": "div_code_body_2",
                "props": "collapsed;"
            },
            "code_date": {
                "content": "Created: Fri Mar 22 21:05:47 2013, modified: Fri Mar 22 21:05:47 2013",
                "id": "div_code_date_2",
                "props": ""
            },
            "code_header": {
                "content": "helper.py -lineno -tag function_something -include",
                "id": "div_code_header_2",
                "props": "intoc;"
            }
        },
        "id": 2,
        "type": "code"
    },
    {
        "content": {
            "text_body": {
                "content": "This functionality is handy, if one wants to list the content of some file. We only have to enter the file name, and press enter. Additionally, an argument can be supplied, in which case, only the first or last n lines will be printed.<br>",
                "id": "div_text_body_2",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Working with headers 1.",
                "id": "div_text_header_2",
                "props": "searchable;intoc;"
            }
        },
        "id": 2,
        "type": "text"
    },
    {
        "content": {
            "head_body": {
                "content": "# comment 1<br># comment 2<br>12 3<br>23 22<br>2132 123<br>55 99",
                "id": "div_head_body_1",
                "props": "searchable;"
            },
            "head_date": {
                "content": "Created: Sat Dec 15 23:54:22 2012, modified: Sat Dec 15 23:53:33 2012",
                "id": "div_head_date_1",
                "props": ""
            },
            "head_header": {
                "content": "test.dat",
                "id": "div_head_header_1",
                "props": "intoc;"
            }
        },
        "id": 1,
        "type": "head"
    },
    {
        "content": {
            "text_body": {
                "content": "If we supply an argument, we can print the first or last n lines as follows<br>",
                "id": "div_text_body_3",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Working with headers 2.",
                "id": "div_text_header_3",
                "props": "searchable;intoc;"
            }
        },
        "id": 3,
        "type": "text"
    },
    {
        "content": {
            "head_body": {
                "content": "# comment 1<br># comment 2",
                "id": "div_head_body_2",
                "props": "searchable;"
            },
            "head_date": {
                "content": "Created: Sat Dec 15 23:54:22 2012, modified: Sat Dec 15 23:53:33 2012",
                "id": "div_head_date_2",
                "props": ""
            },
            "head_header": {
                "content": "test.dat 2",
                "id": "div_head_header_2",
                "props": "intoc;"
            }
        },
        "id": 2,
        "type": "head"
    },
    {
        "content": {
            "head_body": {
                "content": "2132 123<br>55 99",
                "id": "div_head_body_3",
                "props": "searchable;"
            },
            "head_date": {
                "content": "Created: Sat Dec 15 23:54:22 2012, modified: Sat Dec 15 23:53:33 2012",
                "id": "div_head_date_3",
                "props": ""
            },
            "head_header": {
                "content": "test.dat -2",
                "id": "div_head_header_3",
                "props": "intoc;"
            }
        },
        "id": 3,
        "type": "head"
    },
    {
        "content": {
            "text_body": {
                "content": "Plots can easily be included in a notebook. A plot cell has three usable subcells. The first one is the caption/title of the plot. This will be included in the table of contents, and this will also be used as the caption, when one converts the notebook to pdf via LaTeX. <br><br>The second cell is the matplotlib code that generates the plot. At the time of writing this, this code is going to be included in the pdf output, while in the notebook, it can be made hidden by clicking on the gray arrow at the top. <br><br>The third subcell is the plot itself. In case the plot cannot be generated (e.g., due to a syntax error in the code), the traceback will be returned instead. A link to the file that was generated is also displayed. If this feature is not required, the corresponding div, .div_plot_file, can be set to <b>display: none;</b> in the CSS. This would still save the link in the json file, so that later on it can still be retrieved, but the content will not be displayed. <br><br>Note that gnuplot also can be used as the plotting backend by adding #gnuplot or # gnuplot on the first line of the code.<br>",
                "id": "div_text_body_6",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Adding plots",
                "id": "div_text_header_6",
                "props": "searchable;intoc;"
            }
        },
        "id": 6,
        "type": "text"
    },
    {
        "content": {
            "plot_caption": {
                "content": "Time evolution of the displacement of a harmonic oscillator",
                "id": "div_plot_caption_1",
                "props": "searchable;intoc;"
            },
            "plot_file": {
                "content": "notebooks/nothon.note_plot_1.png",
                "id": "div_plot_file_1",
                "props": ""
            },
            "plot_header": {
                "content": "plot(sin(x), 'ro')<br>xlabel('Time [s]')<br>ylabel('Displacement [a.u.]')<br>",
                "id": "div_plot_header_1",
                "props": "collapsed;"
            }
        },
        "id": 1,
        "type": "plot"
    },
    {
        "content": {
            "text_body": {
                "content": "In addition to containing raw text, courtesy of MathJaX, a text box can also deal with LaTeX code. This can be inserted by pressing Cntr-Alt-M (display style), or Alt-M (inline). By default, formulae will be displayed with a light blue background, but this can be changed in the CSS file. Note that by pressing the hotkey combinations above, the user will be presented with empty math containers. However, it is also possible to turn a piece of text into a math formula. If teh above-mentioned hotkeys are pressed while some text is selected, this text will become the body of the math formula. <br><br>If we wanted to solve the quadratic equation <span alt=\"\\(ax^2 + bx + x = 0\\)\" class=\"nothon_math\">\\(ax^2 + bx + x = 0\\)</span>, we would have to look up the solution formula<br><div alt=\"\\[<br>x_{1,2} = \\frac{-b\\pm\\sqrt{b^2-4ac}}{2}<br>\\]\" class=\"nothon_math\">\\[<br>x_{1,2} = \\frac{-b\\pm\\sqrt{b^2-4ac}}{2}<br>\\]</div>Some markup can be added to text. <b>Cntr-I</b> is going to make the text <i>italic</i>, <b>Cntr-B</b> turns it <b>boldface</b>,<b> Cntr-O</b> adds <span style=\"background-color: rgb(255, 255, 0);\">highlighting</span>, while <b>Cntr-U</b> will <u>underline</u> the text.<br><br>Notebooks can be converted to pdf via LaTeX by calling python/latex.py with the notebook file as the single argument. Customisation of the latex file should be done through the templates in templates/. If pdf output is needed, self.plot_pdf_output has to be set to True in the resource file.<br><br>Sticky notes can also be added to a section cell. These are small yellow boxes that can be collapsed, so that they do not take up space. <span class=\"note\"><button class=\"note_button\" onclick=\"note_toggle(this);\">Note</button><span style=\"display: inline;\">A typical note cell looks like this.</span></span> By clicking on the 'Note' button, the content of the note will become hidden. <br>Ordinary text can be turned into a sticky note by highlighting it, and then clicking on the 'Note' button. <br><br>Links can be created in a similar fashion. When clicking on 'Link' button, any highlighted text will be converted to a link with the text being the target and the text of the hyperlink. By clicking on the 'Link' button, the hyperlink will be opened for editing, where both the text, and the target can be changed. <br>",
                "id": "div_text_body_1",
                "props": "searchable;"
            },
            "text_header": {
                "content": "This is a text box with some LaTeX code",
                "id": "div_text_header_1",
                "props": "searchable;intoc;"
            }
        },
        "id": 1,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "The notebook features a simple scientific calculator, based on <a href=\"http://mathjs.org/\">http://mathjs.org/</a>. This is meant to be used as a scratch pad for quick, dirty, and disposable calculations. However, results and instructions can be inserted into a section/paragraph. The calculator history is preserved, even if the user navigates to another notebook.<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>  ",
                "id": "div_text_body_15",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Calculator",
                "id": "div_text_header_15",
                "props": "searchable;intoc;"
            }
        },
        "id": 15,
        "type": "text"
    }
]
}