{
"title" : "Comments on using the nothon notebook<br>",
"type": "notebook",
"directory" : "/home/v923z/sandbox/nothon/notebooks/",
"date" : "Sat Apr 13 2013 09:13:22 GMT+0200 (CEST)",
"nothon version" : 1.2,
"notebook" : [
    {
        "content": {
            "text_body": {
                "content": "The most recent version of the source code resides at https://github.com/v923z/nothon<br><br>After starting nothon.py, the notebook can be accessed at address <br><br>http://127.0.0.1:8080/?name=somenotebook.note<br><br>If the notebook exists (this should be a JSON file), then its content will be rendered in the browser. If it doesn't exist, then a new notebook with that name will be created. When saving this notebook, its content will be written to disc under the name somenotebook.note. <br><br>Once in the browser, a new div can be added by clicking on the appropriate label under the + sign on the right hand side. The active div's parent (always indicated by a thick right-hand-side border) can be removed by clicking on remove. This operation moves the divide to the trash, which is part of the document, but is hidden. (The trash can be made visible by clicking on the trashbin icon on the lower right corner.) By clicking on recover, either the active block of the trashbin, or if that does not exist, then the last block in the trash is restored to the visible part of the document, and is inserted as the last divide. Blocks of the document can be moved up or down by clicking on the up or down arrow on the right hand side. <br>",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Beginning with nothon<span id=\"marker_5116815878351775\"></span>",
                "props": "searchable;intoc;"
            }
        },
        "id": 7,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "Headers in text, code, and head blocks are evaluated by pressing `Enter`. This moves the cursor to the body of a text header, or send a request to the server to execute and return the output of the corresponding handler function. <br><br>Units can be \"executed\" by pressing `Cntr+Enter`. This will render mathematical formulae in a text block, or execute a plot. If `Shift+Enter` is pressed, a new block of the same type is also inserted into the notebook.",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Usage in general terms",
                "props": "searchable;intoc;"
            }
        },
        "id": 8,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "The visual appearance of a notebook can be influenced by changing the appropriate parameters in the cascaded style sheet. These modifications do not change the behaviour of the server or the client. <br><br>Several aspects of the behaviour of the server can be customised in a resource file. (In future versions, this will be extended to the client, too.) By default, only png files are created, when the user plots in the notebook. By changing the value of the variable self.plot_pdf_output to True, the plotting backend will generate pdf output, too. This output can later be included in latex files. <br><br>The ordering of the directory tree can be customised. By default, the server sends the tree ordered linux style, i.e., in each folder, the files are listed first, and then the folders. By setting the variable self.dirlisting_style to \"windows\", folders will be shown first, and then files.<br><br>When working with code (see below), it might be useful to include only a function or a segment of a code file. This can be done by defining a start and end tag in the source code, and supplying that to the code handler. In order for the code highlighter to know what amounts to the beginning/ending of a code segment, the tag is prepended and appended with a beginning/closing string. This can be defined in the variable self.code_delimiter. E.g., if self.code_delimiter = ('*-', '-*'), then the code should be enclosed between the tags <br><br>&nbsp;&nbsp;&nbsp; *- some_tag<br>&nbsp;&nbsp;&nbsp; .... code ....<br>&nbsp;&nbsp; some_tag -*<br><br>The user can define arbitrary tag combination. <br>",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Customisation",
                "props": "searchable;intoc;"
            }
        },
        "id": 9,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "Arbitrary code residing on the hard disc can conveniently be displayed. All one has to do is give the file name in a code cell.<br>",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Code segments 1.",
                "props": "searchable;intoc;"
            }
        },
        "id": 4,
        "type": "text"
    },
    {
        "content": {
            "code_body": {
                "content": "import os\n\ndef retreive_header(args):\n\thead = args.split('<br>')\n\tsp = head[0].split(' ')\n\tif not os.path.exists(sp[0]): \n\t\treturn \"File doesn't exist\"\n\tif len(sp) == 1: n = 10\n\t# TODO: elif sp[1] == '#':\t\n\telse: n = int(sp[1])\n\tfin = open(sp[0], 'r')\t\n\t# *- function_something \n\tif n > 0:\n\t\tlines = []\n\t\tit = 0\n\t\tfor line in fin:\n\t\t\tlines.append(line.rstrip('\\n\\r'))\n\t\t\tit += 1\n\t\t\tif it >= n: break\n\t# function_something -*\n\tif n < 0:\n\t\tlines = fin.readlines()\n\t\tlines = lines[-10:]\n\tfin.close()\t\n\treturn '<br>'.join([x.rstrip('\\n\\r') for x in lines])\n",
                "props": ""
            },
            "code_date": {
                "content": "Created: Fri Mar 22 21:05:47 2013, modified: Fri Mar 22 21:05:47 2013",
                "props": ""
            },
            "code_header": {
                "content": "helper.py",
                "props": "intoc;"
            }
        },
        "id": 1,
        "type": "code"
    },
    {
        "content": {
            "text_body": {
                "content": "Code lines can be numbered by adding -lineno on the command line. In addition, if a start and end tag are defined in the source file, the code highlighter can be made to display only the segment between the two strings. If -include is specified on the command line, the tags are also included in the highlit code. This can be useful when one wants to emphasise that we are dealing with a code segment only.<br>",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Working with code 2.",
                "props": "searchable;intoc;"
            }
        },
        "id": 5,
        "type": "text"
    },
    {
        "content": {
            "code_body": {
                "content": "\t# *- function_something \n\tif n > 0:\n\t\tlines = []\n\t\tit = 0\n\t\tfor line in fin:\n\t\t\tlines.append(line.rstrip('\\n\\r'))\n\t\t\tit += 1\n\t\t\tif it >= n: break\n\t# function_something -*\n",
                "props": ""
            },
            "code_date": {
                "content": "Created: Fri Mar 22 21:05:47 2013, modified: Fri Mar 22 21:05:47 2013",
                "props": ""
            },
            "code_header": {
                "content": "helper.py -lineno -tag function_something -include",
                "props": "intoc;"
            }
        },
        "id": 2,
        "type": "code"
    },
    {
        "content": {
            "text_body": {
                "content": "This functionality might be handy, if one wants to list the content of some file. We only have to enter the file name, and press enter. Additionally, an argument can be supplied, in which case, only the first or last n lines will be printed.<br>",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Working with headers 1.",
                "props": "searchable;intoc;"
            }
        },
        "id": 2,
        "type": "text"
    },
    {
        "content": {
            "head_body": {
                "content": "# comment 1<br># comment 2<br>12 3<br>23 22<br>2132 123<br>55 99",
                "props": "searchable;"
            },
            "head_date": {
                "content": "Created: Sat Dec 15 23:54:22 2012, modified: Sat Dec 15 23:53:33 2012",
                "props": ""
            },
            "head_header": {
                "content": "test.dat",
                "props": "intoc;"
            }
        },
        "id": 1,
        "type": "head"
    },
    {
        "content": {
            "text_body": {
                "content": "If we supply an argument, we can print the first or last n lines as follows<br>",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Working with headers 2.",
                "props": "searchable;intoc;"
            }
        },
        "id": 3,
        "type": "text"
    },
    {
        "content": {
            "head_body": {
                "content": "# comment 1<br># comment 2",
                "props": "searchable;"
            },
            "head_date": {
                "content": "Created: Sat Dec 15 23:54:22 2012, modified: Sat Dec 15 23:53:33 2012",
                "props": ""
            },
            "head_header": {
                "content": "test.dat 2",
                "props": "intoc;"
            }
        },
        "id": 2,
        "type": "head"
    },
    {
        "content": {
            "head_body": {
                "content": "2132 123<br>55 99",
                "props": "searchable;"
            },
            "head_date": {
                "content": "Created: Sat Dec 15 23:54:22 2012, modified: Sat Dec 15 23:53:33 2012",
                "props": ""
            },
            "head_header": {
                "content": "test.dat -2",
                "props": "intoc;"
            }
        },
        "id": 3,
        "type": "head"
    },
    {
        "content": {
            "text_body": {
                "content": "Plots can easily be included in a notebook. A plot cell has three usable subcells. The first one is the caption/title of the plot. This will be included in the table of contents, and this will also be used as the caption, when one converts the notebook to pdf via LaTeX. <br><br>The second cell is the matplotlib code that generates the plot. At the time of writing this, this code is going to be included in the pdf output, while in the notebook, it can be made hidden by clicking on the gray area next to it. <br><br>The third subcell is the plot itself. In case the plot cannot be generated (e.g., due to a syntax error in the code), the traceback will be returned instead. <br><br>Note that gnuplot also can be used as the plotting backend by adding #gnuplot or # gnuplot on the first line of the code.<br>",
                "props": "searchable;"
            },
            "text_header": {
                "content": "Adding plots",
                "props": "searchable;intoc;"
            }
        },
        "id": 6,
        "type": "text"
    },
    {
        "content": {
            "plot_caption": {
                "content": "Time evolution of the displacement of a harmonic oscillator",
                "props": "searchable;"
            },
            "plot_file": {
                "content": "notebooks/nothon.note_plot_1.png",
                "props": ""
            },
            "plot_header": {
                "content": "plot(sin(x), 'ro')<br>xlabel('Time [s]')<br>ylabel('Displacement [a.u.]')<br>",
                "props": ""
            }
        },
        "id": 1,
        "type": "plot"
    },
    {
        "content": {
            "text_body": {
                "content": "",
                "props": "searchable;"
            },
            "text_header": {
                "content": "",
                "props": "searchable;intoc;"
            }
        },
        "id": 10,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "",
                "props": "searchable;"
            },
            "text_header": {
                "content": "",
                "props": "searchable;intoc;"
            }
        },
        "id": 11,
        "type": "text"
    },
    {
        "content": {
            "text_body": {
                "content": "In addition to containing raw text, courtesy of MathJaX, a text box can also deal with LaTeX code. This can be inserted by pressing Cntr-Alt-M (display style), or Alt-M (inline).<br>If we wanted to solve the quadratic equation<br>\\[<br>             a\\cdot x^2 + b\\cdot x + c = 0             <br>\\]then you would have to look up the solution formula, <br>\\[<br>             x_{1,2} = \\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}             <br>\\]<br>Some markup can be added to text. <b>Cntr-I</b> is going to make the text <i>italic</i>, <b>Cntr-B</b> turns it <b>boldface</b>,<b> Cntr-O</b> adds <span style=\"background-color: rgb(255, 255, 0);\">highlighting</span>, while <b>Cntr-U</b> will <u>underline</u> the text.<br><br>Notebooks can be converted to pdf via LaTeX by calling python/latex.py with the notebook file as the single argument. Customisation of the latex file should be done through the templates in templates/. If pdf output is needed, self.plot_pdf_output has to be set to True in the resource file.<br><br>\\[<br>     \\begin{eqnarray} a &=& 123 \\\\ b &=& 122 \\end{eqnarray}     <br>\\]<br>",
                "props": "searchable;"
            },
            "text_header": {
                "content": "This is a text box with some LaTeX code",
                "props": "searchable;intoc;"
            }
        },
        "id": 1,
        "type": "text"
    }
]
}